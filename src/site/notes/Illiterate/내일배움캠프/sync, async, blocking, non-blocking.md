---
{"dg-publish":true,"permalink":"/illiterate//sync-async-blocking-non-blocking/","tags":["sync","async","bloking","non-bloking"],"noteIcon":"","created":"2025-03-11T10:24:00","updated":"2025-04-12T23:52:38+09:00"}
---

## TTA (한국정보통신기술협회)의 정의

#### 동기 \[통신망]

주기적인 운동을 하는 개체들이 서로 영향을 주고받거나 받게 됨으로써, 동일한 주기를 갖게 되는 것, 그러한 현상을 동기 현상이라 하고, 동기된 상태를 동기화되었다고 한다. 통신에서는 주로 서로 다른 시스템이나 네트워크에서 클럭 주파수나 비트, 프레임, 워드 등을 일치시키는 데 사용된다.

#### 비동기: 정의 없음

#### 비동기식 \[데이터통신]

송수신 간에 신호를 주고 받으며 작업을 수행하는 방식
비동기식은 시작/정지 방식(start-stop systme)과 단계적 시작/정지 방식(stepped start-stop system)이 있다. 시작/정지 방식은 송신하는 각 문자의 전후에 시작 신호와 정지 신호를 붙여 송수신 간의 동기를 취하는 방식이며, 저속 전송에 사용되고 있다. 단계적 시작 정지 방식은 시작 신호와 정지 신호가 일정하게 정해진 간격에서 일어나는 동기 방식이다.

> [!NOTE] 동기 / 비동기
> 동기와 비동기라는 용어는 매우 일반적인 의미를 가진다. 문맥에 따라서도 매우 다양한 의미로 사용된다. 가령 멀티 스레드 프로그래밍에서 동기화는 하나의 데이터에 대한 동시 접근을 하나의 스레드로 한정한다는 의미이며, 데이터 통신에서는 주파수 위상을 맞추는 것을 말한다.

## 서비스의 호출 방식

프로그램에서의 동기와 비동기는 함수 또는 서비스의 호출 방식에 관한 내용이다

#### 동기식 서비스

동기식 서비스에서는 호출이 종료된 이후에 처리 결과를 확인할 수 있다. 
쉬운 디버깅과, 직관적인 흐름 추적이 가능하다는 장점이 있다.
서비스(혹은 함수 호출)가 종료될 때까지 호출자는 기다려하 하므로 컴퓨팅 자원의 낭비가 생긴다.

#### 비동기식 서비스

비동기식 호출에서는 요청을 서비스가 수신하면 요청을 위한 함수를 다른 스레드에 등록한다. 그리고 실제 처리가 완료되지 않아도 서비스 호출 종료가 이루어지며 응답(개발자가 지정한 값)을 호출자에게 전달한다. 호출자의 관점에서는 비록 요청에 대한 결과를 수신하지 못했음에도 요청이 완료되었기 때문에 결과를 기다리는 시간에 다른 작업을 수행할 수 있고 필요한 시기에 서비스로 부터 받은 응답을 사용하여 처음 요청한 처리가 완료되었는지 확인할 수 있다.

비동기 호출을 지원하는 디자인 패턴: Future Pattern(Promise Pattern), Observer Pattern, Callback function(Node.js), Reactor Pattern(Netty)

##  동기(Synchronous) vs 비동기(Asynchronous)

**기준: 작업을 요청한 주체(예: 호출한 스레드)가 응답을 기다리는지 여부**

|개념|설명|
|---|---|
|**동기 (Synchronous)**|요청한 작업이 끝날 때까지 기다렸다가(응답을 받은 후) 다음 작업을 진행|
|**비동기 (Asynchronous)**|요청한 작업이 끝나지 않아도 다른 작업을 수행하며, 결과가 도착하면 콜백/이벤트로 처리|

#### 예: 식당 주문

- **동기(Sync):** 주문한 후 요리가 나올 때까지 자리에서 기다린다.
- **비동기(Async):** 주문 후 다른 일을 하다가(대화, 전화 등) 음식이 나오면 알람을 받고 먹는다.

---

## 블로킹(Blocking) vs 논블로킹(Non-Blocking)

**기준: 현재 실행 중인 스레드가 대기 상태가 되는지 여부**

|개념|설명|
|---|---|
|**블로킹 (Blocking)**|요청을 보낸 스레드가 결과를 받을 때까지 멈춰서 아무 작업도 못 함|
|**논블로킹 (Non-Blocking)**|요청을 보낸 스레드가 즉시 다음 작업을 수행하며, 결과가 필요할 때만 확인|

#### 예: 전화 통화

- **블로킹(Blocking):** 상대방이 전화를 받을 때까지 계속 기다린다.
    
- **논블로킹(Non-Blocking):** 상대방이 받을지 안 받을지 신경 쓰지 않고 다른 일을 한다.
    

---

## 동기/비동기 & 블로킹/논블로킹 조합

|조합|설명|
|---|---|
|**동기 + 블로킹**|요청 → 응답이 올 때까지 기다림 (ex: 일반적인 함수 호출)|
|**동기 + 논블로킹**|요청 → 처리 완료 여부는 확인하지만 다른 작업 수행 가능|
|**비동기 + 블로킹**|요청 → 결과가 준비될 때까지 대기 (이론적으로는 잘 사용되지 않음)|
|**비동기 + 논블로킹**|요청 → 즉시 다음 작업 수행, 결과가 도착하면 이벤트/콜백으로 처리 (ex: Java `CompletableFuture`)|

---

## Java에서의 예제 코드

#### 동기 + 블로킹 (Synchronous + Blocking)

```java
public String syncBlocking() {
    return someBlockingIOOperation(); // 결과를 기다림 (블로킹)
}
```

#### 비동기 + 논블로킹 (Asynchronous + Non-Blocking)

```java
CompletableFuture.supplyAsync(() -> someIOOperation())
    .thenAccept(result -> System.out.println("결과: " + result));
```

---

## 정리

1. **동기 vs 비동기** → 결과를 기다리는가? (동기: 기다림, 비동기: 기다리지 않음)
    
2. **블로킹 vs 논블로킹** → 스레드가 멈추는가? (블로킹: 멈춤, 논블로킹: 다른 작업 수행 가능)
    
3. **MSA 환경에서 성능을 높이려면**
    
    - 요청 처리를 최적화하려면 **비동기 + 논블로킹** 방식 활용 (ex: Reactor, CompletableFuture, WebFlux)
    - 데이터베이스나 I/O 연산이 많을 경우 **비동기 + 논블로킹**이 효율적
        

**즉, 성능을 높이고 싶다면 `비동기 + 논블로킹`을 적극 활용해야 한다!**

---
출처: 자바네트워크소녀 Netty, gpt
[[Illiterate/내일배움캠프/Spring의  async event 처리 방식 비교\|Spring의  async event 처리 방식 비교]]