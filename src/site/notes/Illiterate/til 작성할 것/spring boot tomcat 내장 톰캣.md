---
{"dg-publish":true,"permalink":"/illiterate/til/spring-boot-tomcat/","tags":["tomcat"],"noteIcon":"","created":"2025-03-08T23:16:00","updated":"2025-03-08T23:16:22+09:00"}
---

## 요청당 스레드 모델 thread-per-request

톰캣과 같은 서블릿 컨테이너에서 실행되는 웹 애플리케이션은 요청당 스레드 thread-per-request 라는 모델을 기반으로 요청을 처리한다.

각 요청에 대해 애플리케이션은 해당 특정 요청을 처리하는 데만 전념할 스레드를 할당하고 요청에 대한 응답이 클라이언트에 반환될 때까지 이 스레드는 오직 그 목적으로만 사용하고 다른 목적으로는 사용하지 않는다.

요청을 처리할 때 I/O와 같은 집약적인 작업이 수행되면 이 작업이 완료될 때까지 스레드를 차단한다. 예를 들어 데이터베이스 읽기가 필요한 경우 데이터베이스에서 데이터를 받을 때까지 스레드는 다른 일을 하지 않고 기다리기만 한다. 이런 종류의 처리를 ==동기화 synchronous==, ==블로킹 blocking== 처리라고 부르는 이유가 여기에 있다.

톰캣은 스레드 풀을 초기화해서 가지고 있는데, 모든 HTTP 요청은 이 스레드 풀을 통해 관리한다. 새로운 요청이 들어왔는데 모든 스레드가 사용 중이면 그 요청은 큐로 들어가 스레드 하나가 사용 가능한 상태로 풀릴 때까지 기다린다. 즉, 톰캣의 스레드 수는 동시에 들어오는 요청을 지원할 수 있는 상한선이 된다. 성능 문제를 디버깅할 때 이것을 기억하면 매우 유용하다. 스레드를 소진하는 경우가 계속 발생하면 스레드 풀에 대한 설정을 변경해 더 많은 요청을 수용할 수 있다. 더 많은 스레드는 결국 더 많은 리소스의 사용을 의미하기 때문에 전통적인 애플리케이션에서는 특정 인스턴스에 더 많은 계산 리소스를 추가한다. 반면 클라우드 네이티브 애플리케이션에서는 수평적 확장 및 더 많은 복제본을 배포한다.

> 요청당 스레드 모델은 블로킹으로 인해 사용 가능한 계산 리소스를 효율적으로 사요하지 못한다. 따라서 애플리케이션이 많은 수의 요구에 응답해야 하는 경우 이 모델은 이상적이지 않을 수 있다.
> 스레드 풀에 대한 최상의 설정을 결정하는 것은 어렵다. 리소스 분석과 모니터링 등 다양한 방법을 통해 설정 값을 시도해 보고 찾아야 한다.

## 설정파일을 통한 톰캣 설정

```yml
server:

  # HTTP 포트: 기본 포트는 8080
  port: 8081

  tomcat:

    # 연결 타임아웃: 클라이언트와 TCP 연결을 수락하고 실제 HTTP 요청을 받기까지 톰캣이 기다리는 최대 시간, 서비스 거부 공격 denial-of-service attack 을 방지하는 데 도움이 된다.
    # 기본 설정값은 20s(20초)
    connection-timeout: 2s

    # 새로운 HTTP 요청을 기다리는 동안 연결을 유지하는 시간
    keep-alive-timeout: 15s

    # 요청당 스레드 모델
    threads:
      # 최대 요청 처리 스레드 수
      max: 50
      # 풀에 항상 유지해야 하는 최소 수
      min-spare: 5
    
```

## WebServerFactoryCustomizer

WebServerFactoryCustomizer Bean을 통해서도 설정할 수 있다.

---
출처: [클라우드 네이티브 스프링 인 액션](https://product.kyobobook.co.kr/detail/S000212731527)

